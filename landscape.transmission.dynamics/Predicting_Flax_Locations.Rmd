---
title: "Predicting Flax Locations"
author: "Keenan Duggal"
date: "7/8/2021"
output:
  pdf_document:
    dev: png
    fig_caption: yes
    toc: no
    toc_depth: 3
  html_document:
    df_print: paged
    toc: no
    toc_depth: 3
geometry: margin=1in
fontsize: 10pt
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.align = "center",
                      fig.height = 6,
                      fig.width = 8,
                      collapse = T,
                      comment = "",
                      prompt=F, 
                      echo = T, 
                      cache = T,
                      #cache.extra = rand_seed,
                      autodep = T, 
                      tidy = T, 
                      tidy.opts=list(width.cutoff=63),
                      dev = 'png')
options(width=63)
```


# Still have to do:

1. Back-correct the 10 m past where the populations actually are problem
1. Find a way to go 2.5 m out to the sides of the trail and take points from there as well (probably using a spatial polygon)
1. Find a way to exclude the trail from data points sampled (if the spatial resolution of the datasets is high enough that this would matter). 
1. Have to exclude from the trail points where the flax populations are (or at least find a way to separate the trail points where flax is present from the ones where there is no flax) 



## Notes: 
- it seems like a few (I believe 4) of the transect gpx files are not in the folder at them moment (e.g. Ian's upper loop transect) 
- i had to delete the last line of data in the spreadsheet I am practicing with because the zero length was causing a bunch of errors
- It would seem according to (http://wiki.gis.com/wiki/index.php/Decimal_degrees) that the accuracy with which we stored the GPS points would get us to a precision of 0.111 m. 


# Next steps: 

- transfer to flax github (look up video) 
- check out the paper 
- Back-correct problem 
- Play around with excluding trail points 



# Setting up the Environment:
```{r}
setwd("/Users/keenanduggal/desktop/Spatial Datasets")
par(bg = 'grey')
library(dplyr)
library(mgcv) 
library(tidyverse)
library(ggplot2)
library(rgdal)
library(raster)
library(ggspatial)
library(rasterVis)
library(gridExtra)
library(geosphere)
library(sf) 
library(sp)
library(leaflet)
library(spatstat)
library(plotKML)
library(sampSurf)
```


# Loading in the Data: 

This cell sets the bounds for all of the spatial datasets and is where we will load in the spatial datasets that we are interested in analyzing in relation to flax (and flax rust) locations.  
```{r}
# Bounds the spatial datasets to speed up computation time: (somewhat arbitrarily at the moment)
area_of_interest <- extent(matrix(c(315000,335000, 4300000,433000), nrow=2,byrow=TRUE))

topography_raw <- "https://rmbl-sdp.s3.us-east-2.amazonaws.com/data_products/released/release1/UER_dem_filled_1m_v2.tif"
topography_adjusted <- paste("/vsicurl/",topography_raw,sep="")
topography <- raster(topography_adjusted, progress='text')
# topography_cropped <- crop(topography, area_of_interest, filename=tempfile(),progress="text")

landcover_raw <- "https://rmbl-sdp.s3.us-east-2.amazonaws.com/data_products/released/release1/UER_landcover_1m_v4.tif"
landcover_adjusted <- paste("/vsicurl/",landcover_raw,sep="")
landcover <- raster(landcover_adjusted, progress='text')
plot(landcover)
# landcover_cropped <- crop(landcover, area_of_interest, filename=tempfile(), progress="text")


surface_water_cover_raw <- "https://rmbl-sdp.s3.us-east-2.amazonaws.com/data_products/released/release1/UER_surface_water_1m_v3.tif"
surface_water_cover_adjusted <- paste("/vsicurl/",surface_water_cover_raw,sep="")
surface_water_cover <- raster(surface_water_cover_adjusted, progress='text')
#surface_water_cover_cropped <- crop(surface_water_cover, area_of_interest, filename=tempfile(),progress="text")

summer_solar_radiation_adjusted <- "/vsicurl/https://rmbl-sdp.s3.us-east-2.amazonaws.com/data_products/released/release2/UER_srad_bareearth_day172_3m_v1.tif"
summer_solar_radiation <- raster(summer_solar_radiation_adjusted, progress='text')


```



This cell reads in the locations of all of the flax population data, determines the Haversine length of each population and then systematically (regular spaced sampling) generates points proportional to the calculated length between the start and end of each flax population. 
```{r}
# Reads in transect file: 
flax_GPS_raw <- read.csv("landscape_transects.csv")

# Specifies all possible transects that were surveyed:
all_transects <- c('RG' , 'GL' , 'WM', 'TR' , 'NP' , 'CL' , 'LG' , 'MB' , 'HM'  , 'CT' , 'CB' , 'SH' , 'DC' , 'VB' , 'BG' , 'CM' , 'BC' , 'WS' , 'UL' , 'RL' , 'ER' , 'ME' , 'OBJ' , 'TC')

# Function input: you can specify which transects you want to use (optional) and you need to put in a level that determines what the function outputs: 
  # 1: original dataframe of flax locations and disease information
  # 2: flax longitudes for all of the generated points
  # 3: flax latitudes for all of the generated points
  # 4: vector of disease statuses for all of the generated points
flax_finder <- function(transects = all_transects, output) {
  
  flax_GPS <- flax_GPS_raw %>% filter(transect %in% transects) %>% dplyr::select(transect, start.lat,
                                                                            start.long,end.lat, end.long, 
                                                                            num.H,	num.D,	incidence) 
  
  
  
  # This chunk calculates and stores the Haversine length of each flax population: 
  begin.coord <- data.frame(lon=flax_GPS$start.long, lat=flax_GPS$start.lat)
  end.coord <- data.frame(lon=flax_GPS$end.long, lat=flax_GPS$end.lat)
  for (i in 1:nrow(flax_GPS)) {
    flax_GPS$length_of_pop[i] <- distHaversine(c(flax_GPS$start.long[i], flax_GPS$start.lat[i]),
                                       c(flax_GPS$end.long[i], flax_GPS$end.lat[i]))
  }
  

  # This chunk creates SpatialLines of each flax population: adapted from
  # https://newbedev.com/convert-begin-and-end-coordinates-into-spatial-lines-in-r
  l_sf <- vector("list", nrow(begin.coord))
  for (i in seq_along(l_sf)){
    l_sf[[i]] <- st_linestring(as.matrix(rbind(begin.coord[i, ], end.coord[i,])))
  }
  l_sfc <- st_sfc(l_sf, crs = "proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
  lines_sp <- as(l_sfc, "Spatial")
  # if you want to  visualize the lines, un-comment this next line: 
  # plot(lines_sp, col = "red", lwd = 3)
  
  
  
  # This chunk generates regularly spaced points along the lines just created and tracks whether each point corresponds to a diseased or healthy flax population: 
  flax_longitudes = c()
  flax_latitudes = c()
  disease_tracker = c()
  population_ids = c() 
  
  for (i in 1:nrow(flax_GPS)) { 
    # The number of points right now  is proportional to the Haversine pop. length and each point is functionally 1m spaced apart because you are selecting the number of points to be equal to the length of the population in meters!
    numOfPoints  <-  round(flax_GPS$length_of_pop[i])
    if (numOfPoints < 1) {numOfPoints = 1} # handles exception of less than 1 point 
    # Performs systematically spaced sampling along the line:
    generated_points = spsample(lines_sp[i], n = numOfPoints, type = "regular") 
    temp_df <- data.frame(generated_points)
    
    for (j in 1:nrow(temp_df)) {
      flax_longitudes <- c(flax_longitudes, temp_df$lon[j])
      flax_latitudes <- c(flax_latitudes, temp_df$lat[j]) 
    }
    # if you want to  visualize the generated points, un-comment this next line: 
    # plot(generated_points, col = "blue", cex = 0.25, add = T) 
    
    # keeps track of which population each generated point is coming from 
    population_ids <- c(population_ids, rep(i, length.out = numOfPoints)) 
    
    # Ensures that the flax population disease status follows each generated point
    disease_status = NULL
    if (flax_GPS$incidence[i] == 1) {disease_status = T} 
    else if (flax_GPS$incidence[i] == 0) {disease_status = F}
    temp_vector <- rep(disease_status, length.out = numOfPoints)
    disease_tracker <- c(disease_tracker, temp_vector) 
  }
  
  # Switch case controls what the function returns:
  if (output == 1) {return(flax_GPS)} 
  else if (output == 2) {return(flax_longitudes)}
  else if (output == 3) {return(flax_latitudes)}
  else if (output == 4) {return(disease_tracker)}
  else if (output == 5) {return(population_ids)}
  else {print("Invalid output level entered")} 
}
 
# Function calls: 
diseased_flax_points <- flax_finder(output = 4) 
flax_longs <- flax_finder(output = 2)
flax_lats <- flax_finder(output = 3)
population_of_points <- flax_finder(output = 5) 


# Creates individual dataframes for all flax locations, diseased flax locations and healthy flax locations in order to have flexibility for later analysis: 
all_flax_locations <-  data.frame(Longitude = flax_longs, Latitude = flax_lats, Disease = diseased_flax_points, Population = population_of_points)
diseased_flax_locations <- all_flax_locations %>% filter(Disease == 1)
healthy_flax_locations <- all_flax_locations %>% filter(Disease == 0)

```


Run this code to check that each point is spaced apart by approximately 1m at the moment run the below code: 
(expect to see multiple series running from 1 to n by approximately 1)
```{r}
for (i in 1:length(unique(all_flax_locations$Population))) {
  population_i <- all_flax_locations %>% filter(Population == i)
  first_point <- population_i %>% slice(1)
  for (j in 2:length(population_i$Population)) {
    distance_from_first_point <- distHaversine(c(first_point$Longitude, first_point$Latitude),
                                       c(population_i$Longitude[j], population_i$Latitude[j]))
    print(
      distHaversine(c(first_point$Longitude, first_point$Latitude),
                                       c(population_i$Longitude[j], population_i$Latitude[j]))
    )
  }
}
```



# This Cell is not finished yet!!!
This cell will contain the function that does the sampling correction (2.5 m on either side of the trail and exclude the trail itself) 
Way of doing this: 
- get all points within 3.0 m of the center of the trail point (will want to do a rectangle with the end points being different gpx points (currently spaced ~ 1m apart) or else you'll run into the risk of sampling the same points more than once), assume that the trail is 1m in length across and therefore exclude that section (leaving 2 2.5m length rectangles on either side of the trail) 
  - to do this I need to find a way to get the coordinates of a point 3m from the center of the trail 
  - this doesn't seem possible or easy enough for me to implement so I think the circle approach would be more feasible
  
Approaches: 
- find endpoints of the rectangle and make a spatialpolygon (i don't know how to do this) 
- make circles instead of rectangles (would end up missing some stuff but you could balance it out by increasing the radius of the circle past 3m! Would have to pick center of the circle at every 3rd meter marker (or whatever you end up deciding the radius should be) to make the radius thing work 
```{r}

# This function will be used to back-correct the flax points 10m to make up for the sampling technique 
  # we of course only want to backcorrect the ends of the flax populations, not all of the flax points as this function currently does. So we will probably put this function in the above flax finder function before you add in the end coordinates (would end up shrinking the populations down). 

correcting_points <- function(list_of_points, dx, dy) {
  original_points <- all_flax_locations %>% dplyr::select(c(Longitude, Latitude)) %>% rename(x = Longitude, y = Latitude)%>% slice(list_of_points)
  original_points$status <- rep("Original", length.out = length(list_of_points))
  
  new_points <- c()
  for (i in list_of_points) {
    lon0 = all_flax_locations$Longitude[i] 
    lat0 = all_flax_locations$Latitude[i]
    lat_new = lat0 + (180/pi)*(dy/6378137)
    lon_new = lon0 + (180/pi)*(dx/6378137)/cos(lat0)
    new_point_status= "New"
    new_point <- data.frame(x = lon_new, y = lat_new, status = new_point_status) 
    new_points <- rbind(new_points, new_point)
  }

  # Visualization: Have to zoom in on the graph to see the difference:
  plot_df <- rbind(original_points, new_points)  
  #print
    (
    ggplot(data=plot_df, aes(x = x, y = y, color = factor(status), shape = factor(status))) +
    geom_point(size = 3) + 
    labs(title = "Visualizing Offset") +
    scale_color_manual(values=c("red","blue")) +
    scale_shape_manual(values= c(18, 20))
    )

return(new_points)
}

correcting_points(list_of_points=c(2, 20, 200, 2000), dx = 3.0, dy = 1.0)




# After we backcorrect the end points of populations with the above function, we can create spatial circles regularly spaced in each population in which we can create sample points in order to collect the spatial dataset information 


# Creating a spatial polygon proof of concept: seems to hard to do with the information we have
x1 <- c(-60,-60,-62,-62,-60)
x2 <-c(-50,-50,-55,-55,-50)
y1 <- c(20,25,25,20,20)
y2 <- c(15,25,25,15,15)
poly1 <- sp::Polygon(cbind(x1,y1))
poly2 <- sp::Polygon(cbind(x2,y2))
TwoPolys <- sp::SpatialPolygons(list(sp::Polygons(list(poly1),ID = "A"),
                                     sp::Polygons(list(poly2), ID = "B")))
plot(TwoPolys)



# Creating a spatial circle proof of concept: (seems like the more feasible approach at the moment: 
circle <- spCircle(radius = 3,
         spUnits = CRS(raster_p4string),
         centerPoint = c(x = all_flax_locations$Longitude[5], y = all_flax_locations$Latitude[5]),
         nptsPerimeter = 100,
         spID = 'tree.1'
         )
plot(circle$spCircle, col="red", lwd = 3)
plot(circle$location, add=TRUE, pch=3)

```



This cell reads in all of the GPX files that we have saved, reduces the number of GPS points for each trail and saves the remaining points to a new spatial dataframe that we can use to determine where we actually surveyed. 
```{r}
# Function input: you can specify which transects you want to use (optional) and you need to put in a level that determines what the function outputs: 
  # 1: trail longitudes for all of the generated trail points
  # 2: trail latitudes for all of the generated trail points
adding_trailPoints <- function(names = all_transects, output) {
  
  # Takes the GPX data for all of the files and appends it all to two empty lists 
  trail_longitudes = c()
  trail_latitudes = c()
  filenames <- paste(names, ".gpx", sep="") 
  for (file in filenames) {
    if (file.exists(file)){
      GPX_points <- readGPX(file)$tracks[[1]][[1]] %>% dplyr::select(lon, lat) %>% rename(Latitude = lat,
                                                                                            Longitude = lon)
      trail_longitudes <- c(trail_longitudes, GPX_points$Longitude)
      trail_latitudes <- c(trail_latitudes, GPX_points$Latitude)
    }
  }
  
  # Switch case controls what the function returns:
  if (output == 1) {return(trail_longitudes)}
  else if (output == 2) {return(trail_latitudes)}
  else {print("Invalid output level entered")}
}


trail_longs <- adding_trailPoints(output = 1)
trail_lats <- adding_trailPoints(output = 2)
trail_locations = data.frame(Longitude = trail_longs, Latitude = trail_lats) 
# Arbitrarily selects every 25th trail GPS point to partially get rid of excess data: (later we'll narrow this number down to match the spatial resolution of our datasets) 
trail_locations_reduced <- trail_locations %>% filter(row_number() %% 25 == 1) 
```


This cell ensures that the GPS coordinates of the flax populations / trail locations and the frame of reference for the spatial datasets are aligned and on the same scale. 
```{r}
# This function takes a dataframe of longitudes and latitudes and performs the spatial alignment: 
spatial_correction <- function(df) {
  coordinates(df) <- ~Longitude+Latitude # creates the SpatialDataframe class in R
  proj4string(df) <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
  raster_p4string <- proj4string(landcover)
  return(spTransform(df,CRS=CRS(raster_p4string)))
}

# Function calls: 
flax_locations_tr <- spatial_correction(all_flax_locations)
diseased_flax_locations_tr <- spatial_correction(diseased_flax_locations)
healthy_flax_locations_tr <- spatial_correction(healthy_flax_locations)
trail_locations_reduced_tr <- spatial_correction(trail_locations_reduced) 
```


# Plotting: 

```{r}
plot(topography) # too slow to be practical for practice 
# plot(landcover)
plot(trail_locations_reduced_tr, col="gray8", cex=0.75, add=T)
plot(healthy_flax_locations_tr, col="lightblue1", cex=0.25, add=T)
plot(diseased_flax_locations_tr, col="red", cex=0.25, add=T)

```



# Analysis: 

This cell extracts the closest (to the flax population locations) pixel raster values of whatever spatial dataset we are interested in: 
```{r}
#View(flax_locations_tr@data)
flax_locations_tr$topography <- extract(topography,flax_locations_tr,method="simple")
flax_locations_tr$landcover <- extract(landcover,flax_locations_tr,method="simple")
flax_locations_tr$watercover <- extract(surface_water_cover,flax_locations_tr,method="simple")
flax_locations_tr$radiation <- extract(summer_solar_radiation, flax_locations_tr, method="simple")
```


look into this 



Creating arbitrary cutoffs to create binary categorical variables: 
```{r}
flax_locations_tr$high_elevation <- flax_locations_tr$topography >= 3200
flax_locations_tr$high_landcover <- flax_locations_tr$landcover > 3
```


Visualizing the data: 
```{r}
ggplot(data = data.frame(flax_locations_tr@data), aes(x=topography, y = ..density..))+
  geom_histogram(aes(fill=Disease), bins = 50) + 
  geom_density(aes(color=Disease)) + 
  scale_fill_hue(l=40) + 
  labs(title = "Elevation Effects on Flax (rust) Distribution ", x = "Elevation (m)") 
  
ggplot(data = data.frame(flax_locations_tr@data), aes(x=radiation, y = ..density..))+
  geom_histogram(aes(fill=Disease), bins = 30) + 
  geom_density(aes(color=Disease)) + 
  scale_fill_hue(l=40) + 
  labs(title = "Solar Radiation Effects on Flax (rust) Distribution ", x = "Radiation (W/m2)") 
  
ggplot(flax_locations_tr@data)+
  geom_histogram(aes(x=(landcover), y = ..count.., fill = Disease), position = 'dodge', binwidth=.5) + 
  labs(title = "Distribution of flax based on landcover", x = "Landcover Category")

```




