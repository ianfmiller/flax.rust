---
title: "Predicting Flax Locations"
author: "Keenan Duggal"
date: "7/8/2021"
output:
  pdf_document:
    dev: png
    fig_caption: yes
    toc: no
    toc_depth: 3
  html_document:
    df_print: paged
    toc: no
    toc_depth: 3
geometry: margin=1in
fontsize: 10pt
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.align = "center",
                      fig.height = 6,
                      fig.width = 8,
                      collapse = T,
                      comment = "",
                      prompt=F, 
                      echo = T, 
                      cache = T,
                      #cache.extra = rand_seed,
                      autodep = T, 
                      tidy = T, 
                      tidy.opts=list(width.cutoff=63),
                      dev = 'png')
options(width=63)
```


# Still have to do:

1. Find a way to go 2.5 m out to the sides of the trail and take points from there as well (probably using a spatial polygon)
1. Find a way to exclude the trail from data points sampled (if the spatial resolution of the datasets is high enough that this would matter). 


## Notes: 
- i had to delete the last line of data in the spreadsheet I am practicing with because the zero length was causing a bunch of errors


## Next steps: 
- Play around with excluding trail points: 
    __look into extract() function! there's a buffer argument and look into changing the method from simple to       billinear__



# Setting up the Environment:
```{r}
setwd("/Users/keenanduggal/desktop/Spatial Datasets")
par(bg = 'grey')
options(digits=10)
library(plyr)
library(dplyr)
library(mgcv) 
library(tidyverse)
library(ggplot2)
library(rgdal)
library(raster)
library(ggspatial)
library(rasterVis)
library(gridExtra)
library(geosphere)
library(sf) 
library(sp)
library(leaflet)
library(spatstat)
library(plotKML)
library(sampSurf)
```


# Loading in the Data: 

This cell sets the bounds for all of the spatial datasets and is where we will load in the spatial datasets that we are interested in analyzing in relation to flax (and flax rust) locations.  
```{r}
# Specifies all possible transects that were surveyed:
all_transects <- c('RG' , 'GL' , 'WM', 'TR' , 'NP' , 'CL' , 'LG' , 'MB' , 'HM'  , 'CT' , 'CB' , 'SH' , 'DC' , 'VB' , 'BG' , 'CM' , 'BC' , 'WS' , 'UL' , 'RL' , 'ER' , 'ME' , 'OBJ' , 'TC')

# Reads in transect file: 
flax_GPS_raw <- read.csv("landscape_transects.csv")

# Bounds the spatial datasets to speed up computation time: (somewhat arbitrarily at the moment)
area_of_interest <- extent(matrix(c(315000,335000, 4300000,433000), nrow=2,byrow=TRUE))

topography_raw <- "https://rmbl-sdp.s3.us-east-2.amazonaws.com/data_products/released/release1/UER_dem_filled_1m_v2.tif"
topography_adjusted <- paste("/vsicurl/",topography_raw,sep="")
topography <- raster(topography_adjusted, progress='text')
# topography_cropped <- crop(topography, area_of_interest, filename=tempfile(),progress="text")

landcover_raw <- "https://rmbl-sdp.s3.us-east-2.amazonaws.com/data_products/released/release1/UER_landcover_1m_v4.tif"
landcover_adjusted <- paste("/vsicurl/",landcover_raw,sep="")
landcover <- raster(landcover_adjusted, progress='text')
plot(landcover)
# landcover_cropped <- crop(landcover, area_of_interest, filename=tempfile(), progress="text")


surface_water_cover_raw <- "https://rmbl-sdp.s3.us-east-2.amazonaws.com/data_products/released/release1/UER_surface_water_1m_v3.tif"
surface_water_cover_adjusted <- paste("/vsicurl/",surface_water_cover_raw,sep="")
surface_water_cover <- raster(surface_water_cover_adjusted, progress='text')
#surface_water_cover_cropped <- crop(surface_water_cover, area_of_interest, filename=tempfile(),progress="text")

summer_solar_radiation_adjusted <- "/vsicurl/https://rmbl-sdp.s3.us-east-2.amazonaws.com/data_products/released/release2/UER_srad_bareearth_day172_3m_v1.tif"
summer_solar_radiation <- raster(summer_solar_radiation_adjusted, progress='text')


```


This cell reads in all of the GPX files that we have saved and saves the  points to a new spatial dataframe that we can use to determine where we surveyed and where the flax populations were. 
```{r}
# Function input: you can specify which transects you want to use (optional) 

adding_trailPoints <- function(names = all_transects, output) {
  
  # Takes the GPX data for all of the files and appends it all to two empty lists 
  trail_longitudes = c()
  trail_latitudes = c()
  filenames <- paste(names, ".gpx", sep="") 
  for (file in filenames) {
    if (file.exists(file)){
      GPX_points <- readGPX(file)$tracks[[1]][[1]] %>% dplyr::select(lon, lat) %>% dplyr::rename(Latitude = lat, Longitude = lon)
      trail_longitudes <- c(trail_longitudes, GPX_points$Longitude)
      trail_latitudes <- c(trail_latitudes, GPX_points$Latitude)
    }
  }
  
return(list(trail_longitudes = trail_longitudes, trail_latitudes = trail_latitudes))

}

adding_trailPoints <- adding_trailPoints()
trail_longs <- adding_trailPoints$trail_longitudes
trail_lats <- adding_trailPoints$trail_latitudes
trail_locations = data.frame(Longitude = trail_longs, Latitude = trail_lats) 

```


This cell __will__ read in the locations of all of the flax population data and sample a number of trail points between the start and end coordinates of the population. 

```{r}
# Function input: you can specify which transects you want to use (optional) 

flax_finder <- function(transects = all_transects) {
  
  flax_GPS <- flax_GPS_raw %>% filter(transect %in% transects) %>% dplyr::select(transect, start.lat,
                                                                            start.long,end.lat, end.long, 
                                                                            num.H,	num.D,	incidence) 

  
# This next large section extracts the flax points from the huge collection of trail points: 

# creates empty lists to hold flax population data: 
indices_of_flax_points <- c() # used to isolate the trail points from the flax_points
flax_long_points <- c()
flax_lat_points <- c()
disease_tracker <- c()
population_tracker <- c() #used to keep track of which population each point is coming from

# for loop that goes through each flax population, extracts all the trail points between the pop endpoints and corrects the endpoint back 10m to account for our sampling method: 
for (i in 1:nrow(flax_GPS)) { 

    # Tracks the disease of each point sampled: 
  disease_status = NULL
  if (flax_GPS$incidence[i] == 1) {disease_status = T} 
  else if (flax_GPS$incidence[i] == 0) {disease_status = F}
  
  # tracks population corresponding to each point 
  population_status = i 
  

  # Finds the trail GPX point corresponding to the start GPS point of the flax population:
    # all the complications in this code were included to anticipate cases where the two points don't       
    # properly align or exist 
  lon_equality_index1 <- which(signif(trail_locations$Longitude, 7) == signif(flax_GPS$start.long[i], 7))
    if(is.empty(lon_equality_index1)) {next}
  lat_equality_index1 <- which(signif(trail_locations$Latitude, 7) == signif(flax_GPS$start.lat[i], 7))
    if(is.empty(lat_equality_index1)) {next}

  if(length(lon_equality_index1) > length(lat_equality_index1)) 
    {
    longer_list <- lon_equality_index1
    shorter_list <- lat_equality_index1
    } else {
      longer_list <- lat_equality_index1
      shorter_list <- lon_equality_index1}

  final_index_start <- longer_list[which(longer_list %in% shorter_list)] %>% head(n=1)

  list_of_differences <- lapply(longer_list, '-', shorter_list) %>% unlist() %>% abs()
  min_difference <- list_of_differences %>% min()
  min_difference_index <- ceiling(which(list_of_differences == min_difference) / length(shorter_list))
  
  alternative_start <- longer_list[min_difference_index]
  if (!is.empty(final_index_start)) {final_index_start = final_index_start}
  else if (min_difference < 100) 
    {final_index_start = alternative_start}
  else {next}

  # Finds the trail GPX point corresponding to the end GPS point of the flax population:
    # all the complications in this code were included to anticipate cases where the two points don't
    # properly align or exist  
  lon_equality_index2 <- which(signif(trail_locations$Longitude, 7) == signif(flax_GPS$end.long[i], 7))
  if(is.empty(lon_equality_index2)) {next}
  
  lat_equality_index2 <- which(signif(trail_locations$Latitude, 7) == signif(flax_GPS$end.lat[i], 7))
  if(is.empty(lat_equality_index2)) {next}

  if(length(lon_equality_index2) > length(lat_equality_index2)) 
    {
    longer_list2 <- lon_equality_index2
    shorter_list2 <- lat_equality_index2
    } else {
      longer_list2 <- lat_equality_index2
      shorter_list2 <- lon_equality_index2}

  final_index_end <- longer_list2[which(lon_equality_index2 %in% lat_equality_index2)] %>% tail(n=1)
  
  list_of_differences2 <- lapply(longer_list2, '-', shorter_list2) %>% unlist() %>% abs()
  min_difference2 <- list_of_differences2 %>% min()
  min_difference_index2 <- ceiling(which(list_of_differences2 == min_difference2) / length(shorter_list2))
    
  alternative_end <- longer_list2[min_difference_index2]
  if (!is.empty(final_index_end)) {final_index_end = final_index_end}
  else if (min_difference2 < 100) 
    {final_index_end = alternative_end}
  else {next}

  # Subsets the trail location data to exclusively refer to a single population 
    # note: problems might be coming from this step if the start index and end index somehow don't refer to the same population. Should look into this further. 
  
  # Temporary solution so that the code stops breaking: (captures 3/4 of the populations) 
  if ((final_index_end - final_index_start < 0) || abs(final_index_end - final_index_start < 0) > 100) {
    next}
  
  pop_points <- trail_locations %>% slice(final_index_start:final_index_end)


  # This step corrects each endpoints by moving it 10m backwards along the trail. 
  corrected_end_index <- NULL 
  for (j in 1:nrow(pop_points)) {
    if(j == nrow(pop_points)) {break} # avoids edge case to avoid code breaking 
    dist <- distHaversine(
      c(pop_points$Longitude %>% tail(n=1), 
        pop_points$Latitude %>% tail(n=1)),
      c((pop_points$Longitude[(nrow(pop_points) - j)]), 
        (pop_points$Latitude[(nrow(pop_points) - j)]))
      )
  
    if (round(dist) == 10) {
      corrected_end_index = final_index_end - j 
      break()
    }
  }

if (is.null(corrected_end_index)) {corrected_end_index = final_index_end}


# DO any shrinking down of the data here: 
  
  # This chunk calculates and stores the Haversine length of each flax population: 
  begin.coord <- data.frame(lon=flax_GPS$start.long, lat=flax_GPS$start.lat)
  end.coord <- data.frame(lon=flax_GPS$end.long, lat=flax_GPS$end.lat)
  for (i in 1:nrow(flax_GPS)) {
    flax_GPS$length_of_pop[i] <- distHaversine(c(flax_GPS$start.long[i], flax_GPS$start.lat[i]),
                                       c(flax_GPS$end.long[i], flax_GPS$end.lat[i]))
  }
  

final_index_start:corrected_end_index
  
pop_points_corrected <- trail_locations %>% slice(final_index_start:corrected_end_index)
flax_long_points <- c(flax_long_points, pop_points_corrected$Longitude) 
flax_lat_points <- c(flax_lat_points, pop_points_corrected$Latitude) 
temp_vector <- rep(disease_status, length.out = nrow(pop_points_corrected))
temp_vector2 <- rep(population_status, length.out = nrow(pop_points_corrected))
disease_tracker <- c(disease_tracker, temp_vector) 
population_tracker <- c(population_tracker, temp_vector2)


}

return(list(flax_GPS = flax_GPS, flax_long_points = flax_long_points, 
              flax_lat_points = flax_lat_points, disease_tracker = disease_tracker,
              population_tracker = population_tracker))
              
}
 
# Function calls: 
flax_finder <- flax_finder()
flax_longs <- flax_finder$flax_long_points
flax_lats <- flax_finder$flax_lat_points
diseased_flax_points <- flax_finder$disease_tracker
population_of_points <- flax_finder$population_tracker


# Creates individual dataframes for all flax locations, diseased flax locations and healthy flax locations in order to have flexibility for later analysis: 
all_flax_locations <-  data.frame(Longitude = flax_longs, Latitude = flax_lats, Disease = diseased_flax_points, Population = population_of_points)
diseased_flax_locations <- all_flax_locations %>% filter(Disease == 1)
healthy_flax_locations <- all_flax_locations %>% filter(Disease == 0)

```


Use this cell to check to see if the flax population coordinates are relatively aligned with the GPX trail coordinates: 
```{r}
for (i in 1:nrow(flax_GPS)) {
longcheck <- flax_GPS$start.long[i]
latcheck <- flax_GPS$start.lat[i]
result <- trail_locations %>% filter(signif(Longitude, 7) == signif(longcheck, 7))
result1 <- trail_locations %>% filter(signif(Latitude, 7) == signif(latcheck, 7))
if (empty(result) | empty(result1)) {
  cat(" Problem with index:", i, "  ") 
}
}
```


# This Cell is not finished yet!!!
This cell will contain the function that does the sampling correction (2.5 m on either side of the trail and exclude the trail itself) 
Way of doing this: 
- get all points within 3.0 m of the center of the trail point (will want to do a rectangle with the end points being different gpx points (currently spaced ~ 1m apart) or else you'll run into the risk of sampling the same points more than once), assume that the trail is 1m in length across and therefore exclude that section (leaving 2 2.5m length rectangles on either side of the trail) 
  - to do this I need to find a way to get the coordinates of a point 3m from the center of the trail 
  - this doesn't seem possible or easy enough for me to implement so I think the circle approach would be more feasible
  
Approaches: 
- find endpoints of the rectangle and make a spatialpolygon (i don't know how to do this) 
- make circles instead of rectangles (would end up missing some stuff but you could balance it out by increasing the radius of the circle past 3m! Would have to pick center of the circle at every 3rd meter marker (or whatever you end up deciding the radius should be) to make the radius thing work 
```{r}

# This function will be used to back-correct the flax points 10m to make up for the sampling technique 
  # we of course only want to backcorrect the ends of the flax populations, not all of the flax points as this function currently does. So we will probably put this function in the above flax finder function before you add in the end coordinates (would end up shrinking the populations down). 

correcting_points <- function(list_of_points, dx, dy) {
  original_points <- all_flax_locations %>% dplyr::select(c(Longitude, Latitude)) %>% rename(x = Longitude, y = Latitude)%>% slice(list_of_points)
  original_points$status <- rep("Original", length.out = length(list_of_points))
  
  new_points <- c()
  for (i in list_of_points) {
    lon0 = all_flax_locations$Longitude[i] 
    lat0 = all_flax_locations$Latitude[i]
    lat_new = lat0 + (180/pi)*(dy/6378137)
    lon_new = lon0 + (180/pi)*(dx/6378137)/cos(lat0)
    new_point_status= "New"
    new_point <- data.frame(x = lon_new, y = lat_new, status = new_point_status) 
    new_points <- rbind(new_points, new_point)
  }

  # Visualization: Have to zoom in on the graph to see the difference:
  plot_df <- rbind(original_points, new_points)  
  #print
    (
    ggplot(data=plot_df, aes(x = x, y = y, color = factor(status), shape = factor(status))) +
    geom_point(size = 3) + 
    labs(title = "Visualizing Offset") +
    scale_color_manual(values=c("red","blue")) +
    scale_shape_manual(values= c(18, 20))
    )

return(new_points)
}

correcting_points(list_of_points=c(2, 20, 200, 2000), dx = 3.0, dy = 1.0)




# After we backcorrect the end points of populations with the above function, we can create spatial circles regularly spaced in each population in which we can create sample points in order to collect the spatial dataset information 


# Creating a spatial polygon proof of concept: seems to hard to do with the information we have
x1 <- c(-60,-60,-62,-62,-60)
x2 <-c(-50,-50,-55,-55,-50)
y1 <- c(20,25,25,20,20)
y2 <- c(15,25,25,15,15)
poly1 <- sp::Polygon(cbind(x1,y1))
poly2 <- sp::Polygon(cbind(x2,y2))
TwoPolys <- sp::SpatialPolygons(list(sp::Polygons(list(poly1),ID = "A"),
                                     sp::Polygons(list(poly2), ID = "B")))
plot(TwoPolys)



# Creating a spatial circle proof of concept: (seems like the more feasible approach at the moment: 
circle <- spCircle(radius = 3,
         spUnits = CRS(raster_p4string),
         centerPoint = c(x = all_flax_locations$Longitude[5], y = all_flax_locations$Latitude[5]),
         nptsPerimeter = 100,
         spID = 'tree.1'
         )
plot(circle$spCircle, col="red", lwd = 3)
plot(circle$location, add=TRUE, pch=3)

```





This cell ensures that the GPS coordinates of the flax populations / trail locations and the frame of reference for the spatial datasets are aligned and on the same scale. 
```{r}
# This function takes a dataframe of longitudes and latitudes and performs the spatial alignment: 
spatial_correction <- function(df) {
  coordinates(df) <- ~Longitude+Latitude # creates the SpatialDataframe class in R
  proj4string(df) <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
  raster_p4string <- proj4string(landcover)
  return(spTransform(df,CRS=CRS(raster_p4string)))
}

# Function calls: 
flax_locations_tr <- spatial_correction(all_flax_locations)
diseased_flax_locations_tr <- spatial_correction(diseased_flax_locations)
healthy_flax_locations_tr <- spatial_correction(healthy_flax_locations)
trail_locations_reduced_tr <- spatial_correction(trail_locations_reduced) 
```


# Plotting: 

```{r}
plot(topography) # too slow to be practical for practice 
# plot(landcover)
plot(trail_locations_reduced_tr, col="gray8", cex=0.75, add=T)
plot(healthy_flax_locations_tr, col="lightblue1", cex=0.25, add=T)
plot(diseased_flax_locations_tr, col="red", cex=0.25, add=T)

```



# Analysis: 

This cell extracts the closest (to the flax population locations) pixel raster values of whatever spatial dataset we are interested in: 
```{r}
#View(flax_locations_tr@data)
flax_locations_tr$topography <- extract(topography,flax_locations_tr,method="simple")
flax_locations_tr$landcover <- extract(landcover,flax_locations_tr,method="simple")
flax_locations_tr$watercover <- extract(surface_water_cover,flax_locations_tr,method="simple")
flax_locations_tr$radiation <- extract(summer_solar_radiation, flax_locations_tr, method="simple")

```





Creating arbitrary cutoffs to create binary categorical variables: 
```{r}
flax_locations_tr$high_elevation <- flax_locations_tr$topography >= 3200
flax_locations_tr$high_landcover <- flax_locations_tr$landcover > 3
```


Visualizing the data: 
```{r}
ggplot(data = data.frame(flax_locations_tr@data), aes(x=topography, y = ..density..))+
  geom_histogram(aes(fill=Disease), bins = 50) + 
  geom_density(aes(color=Disease)) + 
  scale_fill_hue(l=40) + 
  labs(title = "Elevation Effects on Flax (rust) Distribution ", x = "Elevation (m)") 
  
ggplot(data = data.frame(flax_locations_tr@data), aes(x=radiation, y = ..density..))+
  geom_histogram(aes(fill=Disease), bins = 30) + 
  geom_density(aes(color=Disease)) + 
  scale_fill_hue(l=40) + 
  labs(title = "Solar Radiation Effects on Flax (rust) Distribution ", x = "Radiation (W/m2)") 
  
ggplot(flax_locations_tr@data)+
  geom_histogram(aes(x=(landcover), y = ..count.., fill = Disease), position = 'dodge', binwidth=.5) + 
  labs(title = "Distribution of flax based on landcover", x = "Landcover Category")

```




